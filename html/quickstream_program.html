<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>quickstream: quickstream</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">quickstream
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">quickstream </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#quickstream_intro">Introduction</a></li>
<li class="level1"><a href="#quickstream_options">Command Line Options</a></li>
<li class="level1"><a href="#quickstream_examples">Examples</a><ul><li class="level2"><a href="#quickstream_helloworld">Hello World</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The quickstream command line program.</p>
<h1><a class="anchor" id="quickstream_intro"></a>
Introduction</h1>
<p>
  Usage: quickstream OPTIONS
</p>
<p>
  Run a quickstream flow graph.
</p>
<p>
  What filter modules to run with are given in command-line options. This
 program takes action after each command-line argument it parses, so the
 order of command-line arguments is very important.  A connect option,
 --connect, before you load any filters will have no effect.
</p>
<p>
  This program executes code after parsing each command line option in the
 order that the options are given.  After code for each command line option
 is executed the program will terminate.
</p>
<p>
  All command line options require an preceding option flag.  All command
 line options with no arguments may be given in any of two forms.  The two
 argument option forms below are equivalent:
</p>
<p>
<ul>
       <li>-d
       <li>--display
</ul>
     -display is not a valid option.
</p>
<p>
  All command line options with arguments may be given in any of three
 forms.  The three option examples below are equivalent:
</p>
<p>
<ul>
       <li>-f stdin
       <li>--filter stdin
       <li>--filter=stdin
</ul>
</p>
<p>
     -filter stdin  and  -filter=stdin  are not valid option arguments.
</p>
<h1><a class="anchor" id="quickstream_options"></a>
Command Line Options</h1>
<pre>

   --connect|-c [SEQUENCE]  connect loaded filters in a stream. Loaded filters
                  are numbered starting at zero.  For example:
                  
                     --connect "0 1 2 4"
                  
                  will connect the from filter 0 to filter 1 and from filter 2
                  to filter 4, where filter 0 is the first loaded filter, filter
                  1 is the second loaded filter, and so on.  If no SEQUENCE
                  argument is given, all filters that are not connected yet and
                  that are currently loaded will be connected in the order that
                  they have been loaded.

   --display|-d   display a graphviz dot graph of the stream.  If display is
                  called after the stream is readied (via option --ready) this
                  will show stream channel and buffering details.

   --display-wait|-D  like --display but this waits for the display program to
                  exitbefore going on to the next argument option.

   --filter|-f FILENAME { args ... }  load filter module with filename FILENAME.
                    An independent instance of the filter will be created for
                  each time a filter is loaded and the filters will not share
                  virtual addresses and variables.  Optional arguments passed in
                  curly brackets (with spaces around the brackets) are passed to
                  the module construct() function.  For example:
                  
                        --filter stdin { --name input }
                  
                  will load the "stdin" filter module and pass the arguments in
                  the brackets, --name input, to the filter module loader,
                  whereby naming the filter "input".

   --filter-help|-F FILENAME  print the filter module help to stdout and then
                  exit.

   --dot|-g       print a graphviz dot file of the current graph to stdout.

   --help|-h      print this help to stdout and then exit.

   --no-verbose|-n  turn off verbose printing.  See --verbose.

   --plug|-p "FROM_F TO_F FROM_PORT TO_PORT"  connects two filters with more
                  control over which ports get connected.  FROM_F refers to the
                  filter we are connecting from as a number in order in which
                  the filters are loading starting at 0.  TO_F refers to the
                  filter we are connecting to as a number in order in which the
                  filters are loading starting at 0.  FROM_PORT refers to the
                  port number that we are connecting from as viewed from the
                  "from filter".  TO_PORT refers to the port number that we are
                  connecting to as viewed from the "to filter".  For example:
                  
                       --plug "0 1 2 3"
                  
                  will feed the second filter from the first filter loaded, the
                  feeding, first, filter will output from it's output port
                  number 2, and the second filter will read what is fed on it's
                  input port number 3.

   --ready|-R     ready the stream.  This calls all the filter start() functions
                  that exist and gets the stream ready to flow, except for
                  spawning worker flow threads.

   --run|-r       run the stream.  This readies the stream and runs it.

   --threads|-t NUM  when and if the stream is launched, run at most NUM worker
                  threads.  The default is 7.  If this option is not given
                  before a --run option this option will not effect that --run
                  option.  On the Linux operating system the maximum number of
                  threads a process may have can be gotten from running: cat
                  /proc/sys/kernel/threads-max
                  
                  In quickstream, worker threads are shared between filters. The
                  number of threads that will run is dependent on the stream
                  flow graph that is constructed.  Threads will only be created
                  if when there a filter that is not starved or clogged and all
                  the existing worker threads are busy on another filter.  Think
                  of threads as flowing in the stream graph to where they are
                  needed.
                  
                  quickstream can run with with one worker thread.

   --verbose|-v   print more information to stderr.

   --version|-V   print the quickstream package version and then exit.

</pre>
<h1><a class="anchor" id="quickstream_examples"></a>
Examples</h1>
<h2><a class="anchor" id="quickstream_helloworld"></a>
Hello World</h2>
<p>With quickstream installed and quickstream in your PATH you can run:</p>
<div class="fragment"><div class="line">echo &quot;Hello World!&quot; | quickstream --filter stdin --filter stdout --connect --run</div></div><!-- fragment --><p>You can view a graphviz dot image of the flow graph related to the above program that we ran above by running: </p><div class="fragment"><div class="line">quickstream --filter stdin --filter stdout --connect --display</div></div><!-- fragment --><div class="image">
<img src="stdinStdout.png" alt="stdinStdout.png"/>
</div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
